# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

        vagrant@server-bento:~$ type cd
        cd is a shell builtin

        Относится к внутренним командам оболочки, гораздо быстрее чем внешние команды(пример, cat), т.к. не приходится искать путь до команды

        Относительно cd cчитаю, что так и должно быть.


1. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.

        grep -c <some_string> <some_file>

1. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

        systemd

1. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?

        ls /unexisted_dir 2>/dev/pts/1


1. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

        touch 1.txt learning
        echo "Some" > 1.txt
        cat < 1.txt > learning

        vagrant@server-bento:~$ cat learning
        Some


1. Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

        cat 1.txt 3>&1 >/dev/tty2 >&3

1. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?

        `bash 5>&1` создание файлового дескриптора 5 как дубликат stdout
        На выходе ничего не будет

        `echo netology > /proc/$$/fd/5` - вывод результата направлен в fd 5
        Получим netology

        Результат команды, исполняемой в оболочке, подается на fd 5, а вывод fd 5 направлен в stdout.


1. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

        vagrant@server-bento:~/test$ ls /non_exists 2>&1 | tee test
        ls: cannot access '/non_exists': No such file or directory

        vagrant@server-bento:~/test$ cat test
        ls: cannot access '/non_exists': No such file or directory



1. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?

        Выводит все переменные.
        По аналогии c `env`

1. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.

        **/proc/<PID>/cmdline**
        Файл только для чтения. Командная строка для процесса. Если это зомби-процесс, ничего в этом файле нет, чтение из такого файла вернет 0.
        Аргументы командной строки в этом файле выглядят как строки разделяемы '\0'. В конце последней строки также ставится '\0'

        **/proc/<PID>/exe**
        Это символическая ссылка, содержащая актуальный путь до исполняемых команд.
        При попытке открыть его , откроет исполняемый файл



1. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.

        Самая последняя версия sse4_2

        vagrant@server-bento:~/test$ cat /proc/cpuinfo | grep sse
        flags		: sse sse2 ssse3 sse4_1 sse4_2

1. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:

    ```bash
	vagrant@netology1:~$ ssh localhost 'tty'
	not a tty
    ```

	Почитайте, почему так происходит, и как изменить поведение.


        SSH не устанавливает TTY по-умолчанию, когда передается команда, в отличии.
        Обойти это можно поставив -tt:


        ssh -tt localhost tty
        Одиночный параметр -t установит удаленный TTY в том случае, если есть локальный TTY, -tt устанавливает без условий

        или вот так
        ssh -o 'RequestTTY force' localhost tty


1. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

        Читает STDIN и пишет в stdout и файлы.
        sudo echo предоставляет доступ команде echo ,а не права на запись в файл.
        echo string | sudo tee /root/new_file
        эхо пайпит на вход tee данные и sudo разрешает писать в файл к руту.
